<!DOCTYPE html>
<html>

<title>
	Merge Queue Simulator
</title>

<head>
	<link rel="stylesheet" href="style.css" />
<!--
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
    <script src="game.js" ></script>
-->
</head>

<body style="background-color:#FFF">
    <div class="formframe">
        <form>
            <h2>Generate Input</h2>
            <label for="numPRs">Number of PRs:</label>
            <input type="number" id="numPRs" name="numPRs" value="1000" /><br/><br/>

            <label for="prsPerHour">PRs per Hour:</label>
            <input type="number" id="prsPerHour" name="prsPerHour" value="10"/><br/><br/>

            <label for="buildSpeedFast">Build Speed (Fast):</label>
            <input type="number" id="buildSpeedFast" name="buildSpeedFast" value="60" /></input><br/><br/>

            <label for="buildSuccessRateFast">Build Success Rate (Fast):</label>
            <input type="number" id="buildSuccessRateFast" name="buildSuccessRateFast" min="0" max="100" step="0.1" value="99" />%<br/><br/>

            <label for="buildSpeedVarianceFast">Build Speed Variance (Fast):</label>
            <input type="number" id="buildSpeedVarianceFast" name="buildSpeedVarianceFast" value="15" /><br/><br/>

            <label for="buildSpeedFull">Build Speed (Full):</label>
            <input type="number" id="buildSpeedFull" name="buildSpeedFull" value="900" /><br/><br/>

            <label for="buildSuccessRateFull">Build Success Rate (Full):</label>
            <input type="number" id="buildSuccessRateFull" name="buildSuccessRateFull" min="0" max="100" step="0.1" value="95" />%<br/><br/>

            <label for="buildSpeedVarianceFull">Build Speed Variance (Full):</label>
            <input type="number" id="buildSpeedVarianceFull" name="buildSpeedVarianceFull" value="100" /><br/><br/>

            <button type="button" id="generateBtn">Generate</button>
        </form>
    </div>

    <div class="formframe">
        <label for="inputData">Input Data:</label>
        <button type="button" id="copyBtn" onclick="copyToClipboard('inputData')">Copy to Clipboard</button><br/><br/>
        <textarea id="inputData" name="inputData" rows="10" cols="50"></textarea>
    </div>

    <div class="formframe">
        <form>
            <h2>Merge Queue Settings</h2>
            <label for="strategy">Strategy:</label>
            <select id="strategy" name="strategy">
                <option value="simple">Simple</option>
            </select><br/><br/>

            <label for="maxBatchSize">Maximum batch size:</label>
            <input type="number" id="maxBatchSize" name="maxBatchSize"><br/><br/>

            <button type="button" id="simulateBtn">Simulate queue</button>
        </form>
    </div>

    <div class="formframe">
        <label for="outputData">Output Data:</label>
        <button type="button" id="copyOutputBtn" onclick="copyToClipboard('outputData')">Copy to Clipboard</button><br/><br/>
        <textarea id="outputData" name="outputData" rows="10" cols="50"></textarea>
    </div>

    <div class="formframe">
        <h2>Queue Visualization</h2>
        <div style="overflow: auto; max-height: 600px; max-width: 100%; border: 1px solid #ccc;">
            <canvas id="queueCanvas" width="2000" height="1000"></canvas>
        </div>
    </div>

    <script>
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            element.setSelectionRange(0, 99999); // For mobile devices
            navigator.clipboard.writeText(element.value)
                .catch(err => {
                    console.error('Failed to copy: ', err);
                });
        }

        function generatePullRequests() {
            // Get form values
            const numPRs = parseInt(document.getElementById('numPRs').value) || 0;
            const prsPerHour = parseInt(document.getElementById('prsPerHour').value) || 1;
            const buildSpeedFast = parseInt(document.getElementById('buildSpeedFast').value) || 0;
            const buildSuccessRateFast = parseFloat(document.getElementById('buildSuccessRateFast').value) || 0;
            const buildSpeedVarianceFast = parseInt(document.getElementById('buildSpeedVarianceFast').value) || 0;
            const buildSpeedFull = parseInt(document.getElementById('buildSpeedFull').value) || 0;
            const buildSuccessRateFull = parseFloat(document.getElementById('buildSuccessRateFull').value) || 0;
            const buildSpeedVarianceFull = parseInt(document.getElementById('buildSpeedVarianceFull').value) || 0;

            // Generate pull requests
            const pullRequests = [];
            const secondsBetweenPRs = 3600 / prsPerHour;
            let cumulativeTime = 0;

            for (let i = 0; i < numPRs; i++) {
                // Add variance to the time between PRs using exponential distribution
                // This creates realistic bursts while maintaining the expected rate
                const randomFactor = -Math.log(1 - Math.random());
                const timeSinceLastPR = secondsBetweenPRs * randomFactor;
                cumulativeTime += timeSinceLastPR;

                // Calculate queue time with variance (in seconds)
                const queuetime = Math.round(cumulativeTime);

                // Determine if fast build passes (based on success rate)
                const FastBuildPasses = Math.random() * 100 < buildSuccessRateFast;

                // Determine if full build passes (based on success rate)
                const FullBuildPasses = FastBuildPasses && (Math.random() * 100 < buildSuccessRateFull);

                // Generate fast build time with variance (in seconds)
                const fastVariance = (Math.random() - 0.5) * 2 * buildSpeedVarianceFast;
                const FastBuildTime = Math.max(1, Math.round(buildSpeedFast + fastVariance));

                // Generate full build time with variance (in seconds)
                const fullVariance = (Math.random() - 0.5) * 2 * buildSpeedVarianceFull;
                const FullBuildTime = Math.max(1, Math.round(buildSpeedFull + fullVariance));

                pullRequests.push({
                    queuetime: queuetime,
                    FastBuildPasses: FastBuildPasses,
                    FullBuildPasses: FullBuildPasses,
                    FastBuildTime: FastBuildTime,
                    FullBuildTime: FullBuildTime
                });
            }

            // Populate the input data textarea with JSON
            document.getElementById('inputData').value = JSON.stringify(pullRequests, null, 2);
        }

        // Add event listener to generate button
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('generateBtn').addEventListener('click', generatePullRequests);
            document.getElementById('simulateBtn').addEventListener('click', simulateAndRender);
            
            // Prevent form submissions to keep inputs editable
            document.querySelectorAll('form').forEach(form => {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    return false;
                });
            });
        });

        function simulateAndRender() {
            const batches = simulateQueue();
            if (batches) {
                renderQueue(batches);
            }
        }

        function simulateQueue() {
            try {
                // Get settings
                const maxBatchSize = parseInt(document.getElementById('maxBatchSize').value) || 1;
                const strategy = document.getElementById('strategy').value;

                // Parse input data
                const inputData = document.getElementById('inputData').value;
                const pullRequests = JSON.parse(inputData);

                if (!Array.isArray(pullRequests) || pullRequests.length === 0) {
                    alert('Invalid or empty input data. Please generate pull requests first.');
                    return;
                }

                // Create batches
                const batches = [];
                let currentBatch = null;
                let currentBatchEndTime = 0;

                for (let i = 0; i < pullRequests.length; i++) {
                    const pr = pullRequests[i];
                    
                    // Check if we need to start a new batch
                    const needNewBatch = !currentBatch || 
                                        currentBatch.pullRequests.length >= maxBatchSize ||
                                        currentBatchEndTime < pr.queuetime;

                    if (needNewBatch) {
                        // Save the previous batch if it exists
                        if (currentBatch) {
                            batches.push(currentBatch);
                        }

                        // Start a new batch
                        currentBatch = {
                            pullRequests: []
                        };
                        currentBatchEndTime = 0;
                    }

                    // Add PR to current batch
                    currentBatch.pullRequests.push(pr);

                    // Update the batch end time (when this PR's fast build would complete)
                    currentBatchEndTime = pr.queuetime + pr.FastBuildTime;
                }

                // Don't forget to add the last batch
                if (currentBatch && currentBatch.pullRequests.length > 0) {
                    batches.push(currentBatch);
                }

                // Populate the output data textarea with JSON
                document.getElementById('outputData').value = JSON.stringify(batches, null, 2);

                return batches;

            } catch (error) {
                alert('Error simulating queue: ' + error.message);
                console.error('Simulation error:', error);
                return null;
            }
        }

        function renderQueue(batches) {
            const canvas = document.getElementById('queueCanvas');
            const ctx = canvas.getContext('2d');
            
            // Constants for rendering
            const ROW_HEIGHT = 30;
            const PR_RADIUS = 8;
            const DIAMOND_SIZE = 10;
            const X_OFFSET = 50;
            const Y_OFFSET = 50;
            const TIME_SCALE = 0.1; // pixels per second
            
            // Calculate total rows needed and maximum width
            let totalRows = 0;
            let maxWidth = 0;
            
            for (const batch of batches) {
                totalRows += batch.pullRequests.length + 1; // PRs + batch separator row
                
                // Find the rightmost point (last PR's queue time + fast build + full build)
                const lastPR = batch.pullRequests[batch.pullRequests.length - 1];
                let maxFullBuildTime = 0;
                for (const pr of batch.pullRequests) {
                    if (pr.FullBuildTime > maxFullBuildTime) {
                        maxFullBuildTime = pr.FullBuildTime;
                    }
                }
                const batchEndX = X_OFFSET + (lastPR.queuetime + lastPR.FastBuildTime + maxFullBuildTime) * TIME_SCALE;
                if (batchEndX > maxWidth) {
                    maxWidth = batchEndX;
                }
            }
            
            // Set canvas dimensions before drawing
            const requiredHeight = Y_OFFSET + (totalRows + 1) * ROW_HEIGHT;
            const requiredWidth = maxWidth + X_OFFSET;
            canvas.height = Math.max(1000, requiredHeight);
            canvas.width = Math.max(2000, requiredWidth);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let currentRow = 0;
            
            // Render each batch
            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                const prs = batch.pullRequests;
                
                // Find max full build time for this batch
                let maxFullBuildTime = 0;
                for (const pr of prs) {
                    if (pr.FullBuildTime > maxFullBuildTime) {
                        maxFullBuildTime = pr.FullBuildTime;
                    }
                }
                
                // Render each PR in the batch
                for (let prIndex = 0; prIndex < prs.length; prIndex++) {
                    const pr = prs[prIndex];
                    const y = Y_OFFSET + currentRow * ROW_HEIGHT;
                    const x = X_OFFSET + pr.queuetime * TIME_SCALE;
                    
                    // Draw PR circle (black)
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(x, y, PR_RADIUS, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw fast build rectangle (green)
                    ctx.fillStyle = pr.FastBuildPasses ? 'green' : 'red';
                    const fastBuildWidth = pr.FastBuildTime * TIME_SCALE;
                    ctx.fillRect(x + PR_RADIUS, y - PR_RADIUS, fastBuildWidth, PR_RADIUS * 2);
                    
                    currentRow++;
                }
                
                // Draw batch separator (diamond and full build rectangle)
                const lastPR = prs[prs.length - 1];
                const diamondY = Y_OFFSET + currentRow * ROW_HEIGHT;
                const diamondX = X_OFFSET + (lastPR.queuetime + lastPR.FastBuildTime) * TIME_SCALE;
                
                // Draw diamond
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.moveTo(diamondX, diamondY - DIAMOND_SIZE);
                ctx.lineTo(diamondX + DIAMOND_SIZE, diamondY);
                ctx.lineTo(diamondX, diamondY + DIAMOND_SIZE);
                ctx.lineTo(diamondX - DIAMOND_SIZE, diamondY);
                ctx.closePath();
                ctx.fill();
                
                // Draw full build rectangle (red)
                ctx.fillStyle = 'red';
                const fullBuildWidth = maxFullBuildTime * TIME_SCALE;
                ctx.fillRect(diamondX + DIAMOND_SIZE, diamondY - DIAMOND_SIZE, fullBuildWidth, DIAMOND_SIZE * 2);
                
                currentRow++;
            }
        }
    </script>
</body>

</html>